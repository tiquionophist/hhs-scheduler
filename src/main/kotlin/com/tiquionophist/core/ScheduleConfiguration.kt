package com.tiquionophist.core

import com.tiquionophist.util.flattenToSet
import com.tiquionophist.util.prettyName
import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromStream
import kotlinx.serialization.json.encodeToStream
import java.io.File
import java.util.EnumMap

/**
 * User-provided inputs that a generated schedule must satisfy.
 */
@Serializable
data class ScheduleConfiguration(
    val daysPerWeek: Int = 5,
    val periodsPerDay: Int = 4,

    /**
     * Whether to allow the same subject to be taught back-to-back, on the same day.
     *
     * Does not affect scheduling between the end of the previous day and the first period of the following day or
     * scheduling of free periods.
     */
    val allowSubsequentSubjects: Boolean = true,

    /**
     * Whether to allow the same subject (excluding free periods) to be taught more than once in the same day.
     */
    val allowSameDaySubjectRepeats: Boolean = true,

    /**
     * The number of classes in the school.
     */
    val classes: Int,

    /**
     * A map from each [Teacher] to the set of [Subject]s they are permitted to teach.
     *
     * [Teacher]s who should not be scheduled should be omitted from the map; all [Subject] sets must be non-empty.
     */
    val teacherAssignments: Map<Teacher, Set<Subject>> = emptyMap(),

    /**
     * A map from each [Subject] to the number of times per week it ought to be taught (including free periods).
     */
    val subjectFrequency: Map<Subject, Int> = mapOf(Subject.EMPTY to daysPerWeek * periodsPerDay),
) {
    @Transient
    val periodsPerWeek: Int = daysPerWeek * periodsPerDay

    /**
     * A map from each [Subject] to the set of [Teacher]s who are permitted to teach it, generated by
     * [teacherAssignments].
     *
     * Contains only [Subject]s who have at least one [Teacher] assigned; each [Teacher] set is guaranteed to be
     * non-empty.
     */
    @Transient
    val subjectAssignments: EnumMap<Subject, Set<Teacher>> = Subject.values()
        .associateWith { subject ->
            teacherAssignments.filterValues { it.contains(subject) }.keys
        }
        .filterValues { it.isNotEmpty() }
        .let { if (it.isEmpty()) EnumMap(Subject::class.java) else EnumMap(it) }

    /**
     * A map from each teacher in [teacherAssignments] to the minimum number of classes per week they must teach (i.e.
     * the subjects for which they are the only assigned teacher).
     */
    @Transient
    val minClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) ->
            classes * subjects
                .filter { subject -> subjectAssignments[subject]?.size == 1 }
                .sumOf { subjectFrequency[it] ?: 0 }
        }

    /**
     * A map from each teacher in [teacherAssignments] to the maximum number of classes per week they can teach (i.e. if
     * they were to teach all the subjects they are assigned, even if there are other teachers who could teach that
     * subject).
     */
    @Transient
    val maxClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) -> classes * subjects.sumOf { subjectFrequency[it] ?: 0 } }

    /**
     * The [StatSet] gained by students in each class per week as a result of the subjects being taught.
     */
    @Transient
    val classStats: StatSet = subjectFrequency.flatMap { (subject, times) -> List(times) { subject.stats } }.sum()

    /**
     * Verifies that this configuration is valid, returning a list of user-readable error messages for any issues.
     */
    fun validationErrors(): List<String> {
        val errors = mutableListOf<String>()

        if (classes <= 0) {
            errors += "Must have >0 classes."
        }

        if (subjectFrequency.values.sum() != periodsPerWeek) {
            errors += "${subjectFrequency.values.sum()} subjects assigned per week; must be $periodsPerWeek."
        }

        teacherAssignments.forEach { (teacher, subjects) ->
            if (subjects.isEmpty()) {
                errors += "${teacher.fullName} has no assigned subjects."
            }
        }

        val missingSubjects = subjectFrequency.keys.minus(teacherAssignments.values.flattenToSet()).minus(Subject.EMPTY)
        missingSubjects.forEach { subject ->
            errors += "${subject.prettyName} is not taught by any teachers."
        }

        minClassesTaughtPerTeacher.forEach { (teacher, minClasses) ->
            if (minClasses > periodsPerWeek) {
                errors += "${teacher.fullName} must teach at least $minClasses classes per week, which is impossible."
            }
        }

        Classroom.values().forEach { classroom ->
            val subjectsInClassroom = subjectFrequency
                .filterKeys { it.classrooms?.size == 1 && it.classrooms.contains(classroom) }

            val classesPerWeek = classes * subjectsInClassroom.values.sum()
            if (classesPerWeek > periodsPerWeek) {
                errors += "${classroom.canonicalName} must be occupied at least $classesPerWeek times per week (by " +
                        "${subjectsInClassroom.keys.sorted().joinToString { it.prettyName }}), which is impossible."
            }
        }

        return errors
    }

    fun save(file: File) {
        file.outputStream().use { json.encodeToStream(this, it) }
    }

    companion object {
        /**
         * The default configuration used when starting the application.
         */
        val EMPTY = ScheduleConfiguration(classes = 2)

        private val json = Json {
            prettyPrint = true
            encodeDefaults = true
            allowStructuredMapKeys = true
        }

        fun loadOrError(file: File): ScheduleConfiguration {
            return file.inputStream().use { json.decodeFromStream(it) }
        }

        fun loadOrNull(file: File): ScheduleConfiguration? {
            return runCatching { loadOrError(file) }.getOrNull()
        }

        /**
         * Returns a subject frequency map from the given [subjectFrequency] with [Subject.EMPTY] set to the number of
         * missing slots per week. Also removes any subjects with zero frequency.
         */
        fun fillFreePeriods(periodsPerWeek: Int, subjectFrequency: Map<Subject, Int>): Map<Subject, Int> {
            val totalFrequency = subjectFrequency.filterKeys { it != Subject.EMPTY }.values.sum()
            val freePeriods = (periodsPerWeek - totalFrequency).coerceAtLeast(0)
            return subjectFrequency
                .plus(Subject.EMPTY to freePeriods)
                .filterValues { it > 0 }
        }
    }
}
