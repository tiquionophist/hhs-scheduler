package com.tiquionophist.core

import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import java.io.File
import java.util.EnumMap

/**
 * User-provided inputs that a generated schedule must satisfy.
 */
@Serializable
data class ScheduleConfiguration(
    val daysPerWeek: Int = 5,
    val periodsPerDay: Int = 4,

    /**
     * The number of classes in the school.
     */
    val classes: Int,

    /**
     * A map from each [Teacher] to the set of [Subject]s they are permitted to teach.
     *
     * [Teacher]s who should not be scheduled should be omitted from the map; all [Subject] sets must be non-empty.
     */
    val teacherAssignments: Map<Teacher, Set<Subject>>,

    /**
     * A map from each [Subject] to the number of times per week it ought to be taught (including free periods).
     */
    val subjectFrequency: Map<Subject, Int>,
) {
    @Transient
    val periodsPerWeek: Int = daysPerWeek * periodsPerDay

    /**
     * A map from each [Subject] to the set of [Teacher]s who are permitted to teach it, generated by
     * [teacherAssignments].
     *
     * Contains only [Subject]s who have at least one [Teacher] assigned; each [Teacher] set is guaranteed to be
     * non-empty.
     */
    @Transient
    val subjectAssignments: EnumMap<Subject, Set<Teacher>> = Subject.values()
        .associateWith { subject ->
            teacherAssignments.filterValues { it.contains(subject) }.keys
        }
        .filterValues { it.isNotEmpty() }
        .let { if (it.isEmpty()) EnumMap(Subject::class.java) else EnumMap(it) }

    /**
     * A map from each teacher in [teacherAssignments] to the minimum number of classes per week they must teach (i.e.
     * the subjects for which they are the only assigned teacher).
     */
    @Transient
    val minClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) ->
            classes * subjects
                .filter { subject -> subjectAssignments[subject]?.size == 1 }
                .sumOf { subjectFrequency[it] ?: 0 }
        }

    /**
     * A map from each teacher in [teacherAssignments] to the maximum number of classes per week they can teach (i.e. if
     * they were to teach all the subjects they are assigned, even if there are other teachers who could teach that
     * subject).
     */
    @Transient
    val maxClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) -> classes * subjects.sumOf { subjectFrequency[it] ?: 0 } }

    /**
     * The [StatSet] gained by students in each class per week as a result of the subjects being taught.
     */
    @Transient
    val classStats: StatSet = subjectFrequency.flatMap { (subject, times) -> List(times) { subject.stats } }.sum()

    /**
     * Verifies that this configuration is valid, throwing an [IllegalArgumentException] if it is not.
     */
    fun verify() {
        require(classes > 0) { "number of classes must be > 0" }

        require(subjectFrequency.values.sum() == periodsPerWeek) {
            "must have $periodsPerWeek subjects per week, found ${subjectFrequency.values.sum()}"
        }

        teacherAssignments.forEach { (teacher, subjects) ->
            require(subjects.isNotEmpty()) { "${teacher.fullName} has no assigned subjects" }
        }

        val missingSubjects = subjectFrequency.keys.minus(teacherAssignments.values.flatten()).minus(Subject.EMPTY)
        require(missingSubjects.isEmpty()) { "$missingSubjects are in the schedule but not taught by any teachers" }

        minClassesTaughtPerTeacher.forEach { (teacher, minClasses) ->
            require(minClasses <= periodsPerWeek) {
                "${teacher.fullName} must teach at least $minClasses classes per week, which is impossible"
            }
        }
    }

    fun save(file: File) {
        val jsonString = json.encodeToString(this)
        file.bufferedWriter().use {
            it.write(jsonString)
        }
    }

    companion object {
        private val json = Json {
            prettyPrint = true
            encodeDefaults = true
            allowStructuredMapKeys = true
        }

        fun load(file: File): ScheduleConfiguration? {
            return runCatching {
                val lines = file.readLines().joinToString(separator = "\n")
                json.decodeFromString<ScheduleConfiguration>(lines)
            }.getOrNull()
        }
    }
}
