package com.tiquionophist.core

import com.tiquionophist.util.flattenToSet
import com.tiquionophist.util.prettyName
import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromStream
import kotlinx.serialization.json.encodeToStream
import java.io.File
import java.util.EnumMap

/**
 * User-provided inputs that a generated schedule must satisfy.
 */
@Serializable
data class ScheduleConfiguration(
    val daysPerWeek: Int = 5,
    val periodsPerDay: Int = 4,

    /**
     * Whether to allow the same subject (excluding free periods) to be taught more than once in the same day.
     */
    val allowSameDaySubjectRepeats: Boolean = true,

    /**
     * Whether to allow the same subject to be taught back-to-back, on the same day.
     *
     * Does not affect scheduling between the end of the previous day and the first period of the following day or
     * scheduling of free periods.
     *
     * Has no effect if [allowSameDaySubjectRepeats] is false, since that always excludes subsequent repeats.
     */
    val allowSubsequentSubjectsRepeats: Boolean = true,

    /**
     * The number of classes in the school.
     */
    val classes: Int,

    /**
     * A map from each [Teacher] to the set of [Subject]s they are permitted to teach.
     *
     * [Teacher]s who should not be scheduled should be omitted from the map; all [Subject] sets must be non-empty.
     */
    val teacherAssignments: Map<Teacher, Set<Subject>> = emptyMap(),

    /**
     * For each class, a map from each [Subject] to the number of times per week it ought to be taught for that class
     * (including free periods).
     */
    val subjectFrequency: List<Map<Subject, Int>> = List(classes.coerceAtLeast(0)) {
        EnumMap(mapOf(Subject.EMPTY to daysPerWeek * periodsPerDay))
    },
) {
    @Transient
    val periodsPerWeek: Int = daysPerWeek * periodsPerDay

    /**
     * A map from each [Subject] to the set of [Teacher]s who are permitted to teach it, generated by
     * [teacherAssignments].
     *
     * Contains only [Subject]s who have at least one [Teacher] assigned; each [Teacher] set is guaranteed to be
     * non-empty.
     */
    @Transient
    val subjectAssignments: EnumMap<Subject, Set<Teacher>> = Subject.values()
        .associateWith { subject ->
            teacherAssignments.filterValues { it.contains(subject) }.keys
        }
        .filterValues { it.isNotEmpty() }
        .let { if (it.isEmpty()) EnumMap(Subject::class.java) else EnumMap(it) }

    /**
     * A map from each teacher in [teacherAssignments] to the minimum number of classes per week they must teach (i.e.
     * the subjects for which they are the only assigned teacher).
     */
    @Transient
    val minClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) ->
            subjects
                .filter { subject -> subjectAssignments[subject]?.size == 1 }
                .sumOf { subject -> subjectFrequency.sumOf { classFrequency -> classFrequency[subject] ?: 0 } }
        }

    /**
     * A map from each teacher in [teacherAssignments] to the maximum number of classes per week they can teach (i.e. if
     * they were to teach all the subjects they are assigned, even if there are other teachers who could teach that
     * subject).
     */
    @Transient
    val maxClassesTaughtPerTeacher: Map<Teacher, Int> = teacherAssignments
        .mapValues { (_, subjects) ->
            subjects.sumOf { subject -> subjectFrequency.sumOf { classFrequency -> classFrequency[subject] ?: 0 } }
        }

    /**
     * The [StatSet] for the class at [classIndex] gained by students in that class per week as a result of the subjects
     * being taught.
     */
    fun classStats(classIndex: Int): StatSet {
        return subjectFrequency[classIndex]
            .flatMap { (subject, times) -> List(times) { subject.stats } }
            .sum()
    }

    /**
     * Verifies that this configuration is valid, returning a list of user-readable error messages for any issues.
     */
    fun validationErrors(): List<String> {
        val errors = mutableListOf<String>()

        if (classes <= 0) {
            errors += "Must have >0 classes."
        }

        subjectFrequency.forEachIndexed { classIndex, classFrequency ->
            if (classFrequency.values.sum() != periodsPerWeek) {
                errors += "${classFrequency.values.sum()} subjects assigned per week for class ${classIndex + 1}; " +
                        "must be $periodsPerWeek."
            }
        }

        teacherAssignments.forEach { (teacher, subjects) ->
            if (subjects.isEmpty()) {
                errors += "${teacher.fullName} has no assigned subjects."
            }
        }

        val missingSubjects: Set<Subject> = subjectFrequency.flatMapTo(mutableSetOf()) { it.keys }
            .minus(teacherAssignments.values.flattenToSet())
            .minus(Subject.EMPTY)
        missingSubjects.forEach { subject ->
            errors += "${subject.prettyName} is not taught by any teachers."
        }

        minClassesTaughtPerTeacher.forEach { (teacher, minClasses) ->
            if (minClasses > periodsPerWeek) {
                errors += "${teacher.fullName} must teach at least $minClasses classes per week, which is impossible."
            }
        }

        Classroom.values().forEach { classroom ->
            val classesPerWeek = subjectFrequency.sumOf { classFrequency ->
                classFrequency
                    .filterKeys { it.classrooms?.size == 1 && it.classrooms.contains(classroom) }
                    .values
                    .sum()
            }

            if (classesPerWeek > periodsPerWeek) {
                val subjectsInClassroom = subjectFrequency.flatMapTo(mutableSetOf()) { classFrequency ->
                    classFrequency.keys
                        .filter { it.classrooms?.size == 1 && it.classrooms.contains(classroom) }
                }

                errors += "${classroom.canonicalName} must be occupied at least $classesPerWeek times per week (by " +
                        "${subjectsInClassroom.sorted().joinToString { it.prettyName }}), which is impossible."
            }
        }

        return errors
    }

    fun save(file: File) {
        file.outputStream().use { json.encodeToStream(this, it) }
    }

    companion object {
        /**
         * The default configuration used when starting the application.
         */
        val EMPTY = ScheduleConfiguration(classes = 2)

        private val json = Json {
            prettyPrint = true
            encodeDefaults = true
            allowStructuredMapKeys = true
        }

        fun loadOrError(file: File): ScheduleConfiguration {
            return file.inputStream().use { json.decodeFromStream(it) }
        }

        fun loadOrNull(file: File): ScheduleConfiguration? {
            return runCatching { loadOrError(file) }.getOrNull()
        }

        /**
         * Returns a subject frequency map from the given [subjectFrequency] with [Subject.EMPTY] set to the number of
         * missing slots per week for each class. Also removes any subjects with zero frequency.
         */
        fun fillFreePeriods(periodsPerWeek: Int, subjectFrequency: List<Map<Subject, Int>>): List<Map<Subject, Int>> {
            return subjectFrequency.map { classFrequency ->
                val totalFrequency = classFrequency.filterKeys { it != Subject.EMPTY }.values.sum()
                val freePeriods = (periodsPerWeek - totalFrequency).coerceAtLeast(0)
                classFrequency
                    .plus(Subject.EMPTY to freePeriods)
                    .filterValues { it > 0 }
            }
        }
    }
}
